<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="Salem c yuzu" />
  <meta property="og:description" content="jte flood tmr la tapin" />
  <meta property="og:image" content="ya walou ntm" />
  <meta property="og:thumbnail" content="https://cdn.discordapp.com/attachments/1400237818852409405/1400242657111838831/a.jpg?ex=688bed18&is=688a9b98&hm=cf651677b9993aeb5691a4f9d12704a5c0b93d0521ee1696f85f660b54b60d5d&" />
  <meta property="og:url" content="https://7urc.github.io/EboyInLove/" />
  <meta property="og:type" content="website" />
<link rel="stylesheet" href="style.css">
  <link rel="icon" href="logo.jpg" type="image/jpeg">
  <title>Yucord</title>
</head>
<body>
  <div id="sidebar">
    <div class="token-section">
      <input id="token" type="text" placeholder="Token Discord (ALT)" style="width: 100%; margin-bottom: 6px;" oninput="yuzuConnect()">
      <div class="connection-status" id="connectionStatus">Déconnecté</div>
    </div>
    
    <div class="action-buttons">
      <button onclick="yuzuLoadGuilds()" class="action-btn">
        <span class="btn-icon">S</span>
        <span class="btn-text">Serveurs</span>
      </button>
      <button onclick="yuzuLoadDMs()" class="action-btn">
        <span class="btn-icon">D</span>
        <span class="btn-text">DMs / Groupes</span>
      </button>
    </div>

    <div class="sort-controls">
      <div class="sort-section">
        <label class="sort-label">Trier les serveurs:</label>
        <select id="guildSort" onchange="yuzuSortGuilds()">
          <option value="name">Par nom</option>
          <option value="members">Par membres</option>
          <option value="recent">Par activité récente</option>
        </select>
      </div>
      
      <div class="sort-section">
        <label class="sort-label">Trier les DMs:</label>
        <select id="dmSort" onchange="yuzuSortDMs()">
          <option value="recent">Par dernier message</option>
          <option value="name">Par nom</option>
          <option value="unread">Par non lus</option>
        </select>
      </div>
      
      <button onclick="yuzuRefreshData()" class="refresh-btn">
        <span class="btn-icon">R</span>
        <span class="btn-text">Actualiser</span>
      </button>
    </div>

    <div class="group" onclick="yuzuToggleSection('guildList', this)">
      <span class="group-arrow">▼</span>
      Serveurs
    </div>
    <ul id="guildList"></ul>

    <div class="group" onclick="yuzuToggleSection('dmList', this)">
      <span class="group-arrow">▼</span>
      Mp/grp
    </div>
    <ul id="dmList"></ul>
    
    <div id="userProfile" class="user-profile hidden">
      <div class="user-avatar">
        <img id="userAvatar" src="" alt="Avatar">
        <div class="status-indicator online"></div>
      </div>
      <div class="user-info">
        <div class="user-username" id="userUsername">Utilisateur</div>
        <div class="user-status">En ligne</div>
      </div>
      <div class="settings-gear hidden" id="settingsGear" onclick="yuzuOpenSettings()">⚙️</div>
    </div>
  </div>

  <div id="channelSidebar" class="hidden">
    <div id="currentGuildName" class="guild-header"></div>
    <div class="group">Salons</div>
    <ul id="channelList"></ul>
  </div>

  <main id="mainContainer">
    <header id="chatHeader">
      <span id="chatTitle">Aucune conversation</span>
      <div id="topRightLabel">Yuzu</div>
    </header>
    <section id="chat"></section>
    <footer id="inputBox">
      <input id="mentions" type="text" placeholder="Mentions automatiques (ex : @everyone <@id>)" />
      <textarea id="message" placeholder="Message..."></textarea>
    </footer>
  </main>

  <div id="userModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close" onclick="yuzuCloseUserModal()">&times;</span>
      </div>
      <div class="profile-banner" id="profileBanner"></div>
      <div class="profile-info">
        <div class="profile-avatar-large">
          <img id="modalAvatar" src="" alt="Avatar">
          <div class="status-indicator-large online" id="modalStatus"></div>
        </div>
        <div class="profile-details">
          <h2 id="modalUsername">Utilisateur</h2>
          <p id="modalDiscriminator">#0000</p>
          <div class="profile-badges" id="modalBadges"></div>
          <div class="profile-section">
            <h3>À propos de moi</h3>
            <p id="modalBio">Aucune biographie.</p>
          </div>
          <div class="profile-section">
            <h3>Informations</h3>
            <div class="profile-field">
              <span class="field-label">ID utilisateur:</span>
              <span class="field-value" id="modalUserId">N/A</span>
            </div>
            <div class="profile-field">
              <span class="field-label">Création du compte:</span>
              <span class="field-value" id="modalCreatedAt">N/A</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal hidden">
    <div class="settings-modal-content">
      <div class="settings-header">
        <h2>Paramètres</h2>
        <span class="close" onclick="yuzuCloseSettings()">&times;</span>
      </div>
      <div class="settings-body">
        <div class="settings-category">
          <h3>Thème</h3>
          <div class="theme-section">
            <label class="theme-label">Couleur du thème :</label>
            <div class="color-picker-container">
              <div class="color-input-wrapper">
                <input type="color" id="colorPicker" value="#5865f2">
                <input type="text" id="colorDisplay" value="#5865f2" readonly>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="settings-footer">
        <button class="save-btn" onclick="yuzuSaveSettings()">Sauvegarder</button>
      </div>
    </div>
  </div>

  <script>
    let yuzuToken = '';
    let yuzuCurrentChannelId = null;
    let yuzuSocket = null;
    let yuzuUserId = null;
    let yuzuGuildMemberCache = new Map();
    let yuzuGuildsData = [];
    let yuzuDmsData = [];
    let yuzuLastMessageCache = new Map();
    let yuzuNotificationCounts = new Map();
    let yuzuActiveNotifications = new Map();
    let yuzuUserDisplayNameCache = new Map();
    let yuzuConfig = { theme: '#5865f2' };
  
    document.getElementById('message').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        yuzuSendMessageHard();
      }
    });

    // Load config on startup
    yuzuLoadConfig();

    // Color picker event listener
    document.addEventListener('DOMContentLoaded', function() {
      const colorPicker = document.getElementById('colorPicker');
      const colorDisplay = document.getElementById('colorDisplay');
      
      if (colorPicker && colorDisplay) {
        colorPicker.addEventListener('input', function() {
          colorDisplay.value = this.value.toUpperCase();
        });
      }
    });
  
    function yuzuGetDisplayName(user) {
      if (!user) return 'Utilisateur';
      return user.display_name || user.global_name || user.username || 'Utilisateur';
    }

    async function yuzuLoadUserDetails(userId) {
      if (yuzuUserDisplayNameCache.has(userId)) {
        return yuzuUserDisplayNameCache.get(userId);
      }
      
      try {
        const response = await fetch(`https://discord.com/api/v9/users/${userId}`, {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          const userDetails = await response.json();
          yuzuUserDisplayNameCache.set(userId, userDetails);
          return userDetails;
        }
      } catch (error) {
        console.error('Erreur lors du chargement des détails utilisateur:', error);
      }
      
      return null;
    }
    
    async function yuzuConnect() {
      yuzuToken = document.getElementById('token').value;
      if (!yuzuToken) {
        document.getElementById('settingsGear').classList.add('hidden');
        return;
      }

      const statusElement = document.getElementById('connectionStatus');
      if (!statusElement) return;

      statusElement.textContent = 'Connexion...';
      statusElement.className = 'connection-status';

      try {
        const response = await fetch('https://discord.com/api/v9/users/@me', {
          headers: { Authorization: yuzuToken }
        });
        
        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }
        
        const user = await response.json();
        
        if (user && user.id) {
          yuzuUserId = user.id;
          statusElement.textContent = 'Connecté';
          statusElement.className = 'connection-status connected';
          
          // Show settings gear when connected
          document.getElementById('settingsGear').classList.remove('hidden');
          
          yuzuUserDisplayNameCache.set(user.id, user);
          yuzuUpdateUserProfile(user);
        } else {
          throw new Error('Token invalide');
        }
      } catch (error) {
        statusElement.textContent = 'Erreur de connexion';
        statusElement.className = 'connection-status';
        document.getElementById('settingsGear').classList.add('hidden');
        console.error('Erreur:', error);
      }
    }

    function yuzuOpenSettings() {
      document.getElementById('settingsModal').classList.remove('hidden');
      yuzuLoadCurrentTheme();
    }

    function yuzuCloseSettings() {
      document.getElementById('settingsModal').classList.add('hidden');
    }

    function yuzuLoadCurrentTheme() {
      const colorPicker = document.getElementById('colorPicker');
      const colorDisplay = document.getElementById('colorDisplay');
      
      if (colorPicker && colorDisplay) {
        colorPicker.value = yuzuConfig.theme;
        colorDisplay.value = yuzuConfig.theme.toUpperCase();
      }
    }

    function yuzuSaveSettings() {
      const colorPicker = document.getElementById('colorPicker');
      if (colorPicker) {
        yuzuConfig.theme = colorPicker.value;
        yuzuSaveConfig();
        yuzuApplyTheme(yuzuConfig.theme);
        yuzuCloseSettings();
      }
    }

    function yuzuLoadConfig() {
      try {
        // Simulate localStorage behavior with in-memory storage
        if (window.yuzuStoredConfig) {
          yuzuConfig = JSON.parse(window.yuzuStoredConfig);
        }
        yuzuApplyTheme(yuzuConfig.theme);
      } catch (error) {
        console.error('Erreur lors du chargement de la config:', error);
      }
    }

    function yuzuSaveConfig() {
      try {
        // Simulate localStorage behavior with in-memory storage
        window.yuzuStoredConfig = JSON.stringify(yuzuConfig);
      } catch (error) {
        console.error('Erreur lors de la sauvegarde de la config:', error);
      }
    }

    function yuzuApplyTheme(color) {
      const root = document.documentElement;
      
      // Convert hex to slightly darker shade for hover
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      const darkerR = Math.max(0, r - 30);
      const darkerG = Math.max(0, g - 30);
      const darkerB = Math.max(0, b - 30);
      
      const darkerColor = `#${darkerR.toString(16).padStart(2, '0')}${darkerG.toString(16).padStart(2, '0')}${darkerB.toString(16).padStart(2, '0')}`;
      
      root.style.setProperty('--primary-color', color);
      root.style.setProperty('--primary-hover', darkerColor);
    }

    async function yuzuCreateNotification(author, message, channelId) {
      if (author.id === yuzuUserId) return;
      if (channelId === yuzuCurrentChannelId) return;

      const userDetails = await yuzuLoadUserDetails(author.id) || author;
      const displayName = yuzuGetDisplayName(userDetails);

      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.id = `notif-${Date.now()}`;
      
      const avatar = document.createElement('div');
      avatar.className = 'notification-avatar';
      
      const avatarUrl = yuzuGetAvatarUrl(userDetails);
      if (avatarUrl) {
        const img = document.createElement('img');
        img.src = avatarUrl;
        img.alt = displayName;
        img.onerror = () => {
          avatar.innerHTML = displayName.charAt(0).toUpperCase();
        };
        avatar.appendChild(img);
      } else {
        avatar.innerHTML = displayName.charAt(0).toUpperCase();
      }
      
      const content = document.createElement('div');
      content.className = 'notification-content';
      content.innerHTML = `
        <h4>${displayName}</h4>
        <p>${message.length > 50 ? message.substring(0, 50) + '...' : message}</p>
      `;
      
      notification.appendChild(avatar);
      notification.appendChild(content);
      
      notification.onclick = () => {
        yuzuOpenChannel(channelId, displayName);
        yuzuRemoveNotification(notification.id);
      };
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        yuzuRemoveNotification(notification.id);
      }, 5000);
      
      yuzuPlayNotificationSound();
    }

    function yuzuRemoveNotification(notificationId) {
      const notification = document.getElementById(notificationId);
      if (notification) {
        notification.style.animation = 'slideInRight 0.3s ease reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }
    }

    function yuzuPlayNotificationSound() {
  try {
    const audio = new Audio('notif.mp3');
    audio.volume = 0.3;
    audio.play().catch(() => {
      // Fallback au bip généré si le mp3 échoue
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);

      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    });
  } catch (error) {
    console.log('Notification audio indisponible:', error);
  }
}

    function yuzuUpdateNotificationBadge(channelId, increment = true) {
      const currentCount = yuzuNotificationCounts.get(channelId) || 0;
      const newCount = increment ? currentCount + 1 : 0;
      
      if (newCount > 0) {
        yuzuNotificationCounts.set(channelId, newCount);
      } else {
        yuzuNotificationCounts.delete(channelId);
      }
      
      const dmItems = document.querySelectorAll('.dm-item');
      dmItems.forEach(item => {
        const channelIdAttr = item.getAttribute('data-channel-id');
        if (channelIdAttr === channelId) {
          const avatar = item.querySelector('.dm-avatar');
          let badge = avatar.querySelector('.notification-badge');
          
          if (newCount > 0) {
            if (!badge) {
              badge = document.createElement('div');
              badge.className = 'notification-badge';
              avatar.appendChild(badge);
            }
            badge.textContent = newCount > 99 ? '99+' : newCount;
          } else {
            if (badge) {
              badge.remove();
            }
          }
        }
      });
    }

    function yuzuGetAvatarUrl(user) {
      try {
        if (!user || !user.id) return '';
        
        if (user.avatar) {
          const format = user.avatar.startsWith('a_') ? 'gif' : 'png';
          return `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.${format}?size=64`;
        }
        
        const defaultIndex = user.discriminator ? parseInt(user.discriminator) % 5 : parseInt(user.id) % 5;
        return `https://cdn.discordapp.com/embed/avatars/${defaultIndex}.png`;
      } catch (error) {
        console.error('Erreur lors de la génération de l\'URL d\'avatar:', error);
        return '';
      }
    }

    async function yuzuOpenUserProfile(user) {
      try {
        const userDetails = await fetch(`https://discord.com/api/v9/users/${user.id}`, {
          headers: { Authorization: yuzuToken }
        }).then(r => r.json()).catch(() => user);

        const displayName = yuzuGetDisplayName(userDetails);

        document.getElementById('modalAvatar').src = yuzuGetAvatarUrl(userDetails);
        document.getElementById('modalUsername').textContent = displayName;
        document.getElementById('modalDiscriminator').textContent = userDetails.discriminator ? `#${userDetails.discriminator}` : '';
        document.getElementById('modalUserId').textContent = userDetails.id || user.id;
        document.getElementById('modalBio').textContent = userDetails.bio || 'Aucune biographie.';
        
        const createdAt = new Date((parseInt(userDetails.id || user.id) / 4194304) + 1420070400000);
        document.getElementById('modalCreatedAt').textContent = createdAt.toLocaleDateString('fr-FR');
        
        const banner = document.getElementById('profileBanner');
        if (userDetails.banner) {
          const bannerUrl = `https://cdn.discordapp.com/banners/${userDetails.id}/${userDetails.banner}.png?size=600`;
          banner.style.backgroundImage = `url(${bannerUrl})`;
          banner.style.backgroundColor = '';
        } else if (userDetails.accent_color) {
          banner.style.backgroundImage = '';
          banner.style.backgroundColor = `#${userDetails.accent_color.toString(16).padStart(6, '0')}`;
        } else {
          banner.style.backgroundImage = '';
          banner.style.backgroundColor = 'var(--primary-color)';
        }
        
        document.getElementById('userModal').classList.remove('hidden');
      } catch (error) {
        console.error('Erreur lors du chargement du profil:', error);
      }
    }

    function yuzuCloseUserModal() {
      document.getElementById('userModal').classList.add('hidden');
    }

    document.getElementById('userModal').onclick = function(e) {
      if (e.target === this) {
        yuzuCloseUserModal();
      }
    }

    document.getElementById('settingsModal').onclick = function(e) {
      if (e.target === this) {
        yuzuCloseSettings();
      }
    }
    
    async function yuzuSendMessageHard() {
      const message = document.getElementById('message');
      const mentions = document.getElementById('mentions').value.trim();
      if (!yuzuCurrentChannelId || !yuzuToken || !message.value.trim()) return;
      const content = message.value.trim() + (mentions ? ' ' + mentions : '');
      message.value = '';
      
      const userDetails = yuzuUserDisplayNameCache.get(yuzuUserId) || { id: yuzuUserId, username: 'Vous' };
      const displayName = yuzuGetDisplayName(userDetails);
      
      const fakeUser = {
        id: yuzuUserId,
        username: displayName,
        ...userDetails
      };
      await yuzuAppendMessage(fakeUser, content);

      const xhr = new XMLHttpRequest();
      xhr.open('POST', `https://discord.com/api/v9/channels/${yuzuCurrentChannelId}/messages`, true);
      xhr.setRequestHeader('Authorization', yuzuToken);
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify({ content }));
    }

    async function yuzuAppendMessage(author, content) {
      const chat = document.getElementById('chat');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      
      const avatarDiv = document.createElement('div');
      avatarDiv.className = 'avatar';
      if (author.id !== yuzuUserId) {
        avatarDiv.classList.add('clickable');
        avatarDiv.onclick = () => yuzuOpenUserProfile(author);
      }
      
      const avatarUrl = yuzuGetAvatarUrl(author);
      if (avatarUrl) {
        const img = document.createElement('img');
        img.src = avatarUrl;
        img.alt = author.username;
        img.onerror = () => {
          avatarDiv.innerHTML = (author.username || 'U').charAt(0).toUpperCase();
        };
        avatarDiv.appendChild(img);
      } else {
        avatarDiv.innerHTML = (author.username || 'U').charAt(0).toUpperCase();
      }
      
      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      
      const usernameSpan = document.createElement('div');
      usernameSpan.className = 'username';
      if (author.id !== yuzuUserId) {
        usernameSpan.classList.add('clickable');
        usernameSpan.onclick = () => yuzuOpenUserProfile(author);
      }
      usernameSpan.textContent = yuzuGetDisplayName(author);
      
      const textDiv = document.createElement('div');
      textDiv.className = 'message-text';
      textDiv.textContent = content;
      
      contentDiv.appendChild(usernameSpan);
      contentDiv.appendChild(textDiv);
      messageDiv.appendChild(avatarDiv);
      messageDiv.appendChild(contentDiv);
      chat.appendChild(messageDiv);
      chat.scrollTop = chat.scrollHeight;
    }

    function yuzuUpdateUserProfile(user) {
      const profile = document.getElementById('userProfile');
      const avatar = document.getElementById('userAvatar');
      const username = document.getElementById('userUsername');
      
      if (profile && avatar && username) {
        avatar.src = yuzuGetAvatarUrl(user);
        username.textContent = yuzuGetDisplayName(user);
        profile.classList.remove('hidden');
      }
    }

    async function yuzuLoadGuilds() {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch('https://discord.com/api/v9/users/@me/guilds', {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          yuzuGuildsData = await response.json();
          yuzuDisplayGuilds();
        }
      } catch (error) {
        console.error('Erreur lors du chargement des serveurs:', error);
      }
    }

    async function yuzuLoadDMs() {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch('https://discord.com/api/v9/users/@me/channels', {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          yuzuDmsData = await response.json();
          yuzuDisplayDMs();
        }
      } catch (error) {
        console.error('Erreur lors du chargement des DMs:', error);
      }
    }

    function yuzuDisplayGuilds() {
      const list = document.getElementById('guildList');
      list.innerHTML = '';
      
      yuzuGuildsData.forEach(guild => {
        const li = document.createElement('li');
        li.className = 'server-item';
        li.onclick = () => yuzuLoadChannels(guild.id, guild.name);
        
        const avatar = document.createElement('div');
        avatar.className = 'server-avatar';
        if (guild.icon) {
          const img = document.createElement('img');
          img.src = `https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png?size=32`;
          img.alt = guild.name;
          avatar.appendChild(img);
        } else {
          avatar.textContent = guild.name.charAt(0).toUpperCase();
        }
        
        const name = document.createElement('div');
        name.className = 'server-name';
        name.textContent = guild.name;
        
        li.appendChild(avatar);
        li.appendChild(name);
        list.appendChild(li);
      });
    }

    function yuzuDisplayDMs() {
      const list = document.getElementById('dmList');
      list.innerHTML = '';
      
      yuzuDmsData.forEach(dm => {
        const li = document.createElement('li');
        li.className = 'dm-item';
        li.setAttribute('data-channel-id', dm.id);
        
        let displayName = 'DM';
        if (dm.type === 1 && dm.recipients && dm.recipients.length > 0) {
          displayName = yuzuGetDisplayName(dm.recipients[0]);
        } else if (dm.type === 3) {
          displayName = dm.name || 'Groupe';
        }
        
        li.onclick = () => yuzuOpenChannel(dm.id, displayName);
        
        const avatar = document.createElement('div');
        avatar.className = 'dm-avatar';
        
        if (dm.type === 1 && dm.recipients && dm.recipients.length > 0) {
          const avatarUrl = yuzuGetAvatarUrl(dm.recipients[0]);
          if (avatarUrl) {
            const img = document.createElement('img');
            img.src = avatarUrl;
            img.alt = displayName;
            avatar.appendChild(img);
          } else {
            avatar.textContent = displayName.charAt(0).toUpperCase();
          }
        } else {
          avatar.textContent = displayName.charAt(0).toUpperCase();
        }
        
        const name = document.createElement('div');
        name.className = 'dm-name';
        name.textContent = displayName;
        
        li.appendChild(avatar);
        li.appendChild(name);
        list.appendChild(li);
      });
    }

    async function yuzuLoadChannels(guildId, guildName) {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch(`https://discord.com/api/v9/guilds/${guildId}/channels`, {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          const channels = await response.json();
          yuzuDisplayChannels(channels, guildName);
        }
      } catch (error) {
        console.error('Erreur lors du chargement des salons:', error);
      }
    }

   function yuzuDisplayChannels(channels, guildName) {
  const sidebar = document.getElementById('channelSidebar');
  const list = document.getElementById('channelList');
  const header = document.getElementById('currentGuildName');
  
  // Reset et création du header
  header.innerHTML = '';
  
  // Trouver le serveur correspondant
  const guild = yuzuGuildsData.find(g => g.name === guildName);
  
  // Container pour la bannière + nom
  const headerContainer = document.createElement('div');
  headerContainer.className = 'guild-header-container';
  
  if (guild?.banner) {
    const banner = document.createElement('div');
    banner.className = 'guild-banner';
    banner.style.backgroundImage = `url(https://cdn.discordapp.com/banners/${guild.id}/${guild.banner}.png?size=600)`;
    headerContainer.appendChild(banner);
  }
  
  const nameElement = document.createElement('div');
  nameElement.className = 'guild-name';
  nameElement.textContent = guildName;
  headerContainer.appendChild(nameElement);
  
  header.appendChild(headerContainer);
  
  // Liste des salons
  list.innerHTML = '';
  const textChannels = channels.filter(c => c.type === 0).sort((a, b) => a.position - b.position);
  
  textChannels.forEach(channel => {
    const li = document.createElement('li');
    li.className = 'channel-item';
    li.onclick = () => yuzuOpenChannel(channel.id, channel.name);
    
    const hash = document.createElement('span');
    hash.className = 'channel-hash';
    hash.textContent = '#';
    
    const name = document.createElement('span');
    name.className = 'channel-name';
    name.textContent = channel.name;
    
    li.appendChild(hash);
    li.appendChild(name);
    list.appendChild(li);
  });
  
  sidebar.classList.remove('hidden');
}

    async function yuzuOpenChannel(channelId, channelName) {
  // Détection si le salon est un DM
  const isDM = yuzuDmsData.some(dm => dm.id === channelId);
  if (isDM) {
    // Cache la sidebar des serveurs
    document.getElementById('channelSidebar').classList.add('hidden');
  } else {
    // Affiche la sidebar des serveurs si ce n’est pas un DM
    document.getElementById('channelSidebar').classList.remove('hidden');
  }

  yuzuCurrentChannelId = channelId;
  document.getElementById('chatTitle').textContent = isDM ? channelName : `# ${channelName}`;
  document.getElementById('chat').innerHTML = '';

  yuzuUpdateNotificationBadge(channelId, false);

  await yuzuLoadMessages(channelId);

  if (yuzuSocket) yuzuSocket.close();
  yuzuSocket = new WebSocket('wss://gateway.discord.gg/?v=9&encoding=json');

  yuzuSocket.onopen = () => {
    yuzuSocket.send(JSON.stringify({
      op: 2,
      d: {
        token: yuzuToken,
        intents: 32767,
        properties: {
          os: 'linux',
          browser: 'yuzu',
          device: 'yuzu'
        }
      }
    }));
  };



      yuzuSocket.onmessage = ({ data }) => {
        try {
          const payload = JSON.parse(data);
          if (payload.t === 'MESSAGE_CREATE') {
            const msg = payload.d;
            
            if (msg.channel_id === yuzuCurrentChannelId && msg.author.id !== yuzuUserId) {
              yuzuAppendMessage(msg.author, msg.content);
            }
            
            if (msg.author.id !== yuzuUserId) {
              const isDM = yuzuDmsData.some(dm => dm.id === msg.channel_id && (dm.type === 1 || dm.type === 3));
              
              if (isDM && msg.channel_id !== yuzuCurrentChannelId) {
                yuzuCreateNotification(msg.author, msg.content, msg.channel_id);
                yuzuUpdateNotificationBadge(msg.channel_id, true);
              }
            }
            
            yuzuUpdateLastMessageCache(msg.channel_id, msg);
          }
        } catch (error) {
          console.error('Erreur lors du traitement du message WebSocket:', error);
        }
      };

      yuzuSocket.onerror = (error) => {
        console.error('Erreur WebSocket:', error);
      };
    }

    async function yuzuLoadMessages(channelId) {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch(`https://discord.com/api/v9/channels/${channelId}/messages?limit=50`, {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          const messages = await response.json();
          messages.reverse().forEach(msg => {
            yuzuAppendMessage(msg.author, msg.content);
          });
        }
      } catch (error) {
        console.error('Erreur lors du chargement des messages:', error);
      }
    }

    function yuzuUpdateLastMessageCache(channelId, message) {
      yuzuLastMessageCache.set(channelId, message);
    }

    function yuzuSortGuilds() {
      const sortBy = document.getElementById('guildSort').value;
      
      switch(sortBy) {
        case 'name':
          yuzuGuildsData.sort((a, b) => a.name.localeCompare(b.name));
          break;
        case 'members':
          yuzuGuildsData.sort((a, b) => (b.approximate_member_count || 0) - (a.approximate_member_count || 0));
          break;
        case 'recent':
          yuzuGuildsData.sort((a, b) => {
            const lastA = yuzuLastMessageCache.get(a.id);
            const lastB = yuzuLastMessageCache.get(b.id);
            if (!lastA && !lastB) return 0;
            if (!lastA) return 1;
            if (!lastB) return -1;
            return new Date(lastB.timestamp) - new Date(lastA.timestamp);
          });
          break;
      }
      yuzuDisplayGuilds();
    }

    function yuzuSortDMs() {
      const sortBy = document.getElementById('dmSort').value;
      
      switch(sortBy) {
        case 'name':
          yuzuDmsData.sort((a, b) => {
            const nameA = a.type === 1 && a.recipients ? yuzuGetDisplayName(a.recipients[0]) : (a.name || 'Groupe');
            const nameB = b.type === 1 && b.recipients ? yuzuGetDisplayName(b.recipients[0]) : (b.name || 'Groupe');
            return nameA.localeCompare(nameB);
          });
          break;
        case 'recent':
          yuzuDmsData.sort((a, b) => {
            const lastA = yuzuLastMessageCache.get(a.id);
            const lastB = yuzuLastMessageCache.get(b.id);
            if (!lastA && !lastB) return 0;
            if (!lastA) return 1;
            if (!lastB) return -1;
            return new Date(lastB.timestamp) - new Date(lastA.timestamp);
          });
          break;
        case 'unread':
          yuzuDmsData.sort((a, b) => {
            const countA = yuzuNotificationCounts.get(a.id) || 0;
            const countB = yuzuNotificationCounts.get(b.id) || 0;
            return countB - countA;
          });
          break;
      }
      yuzuDisplayDMs();
    }

    function yuzuToggleSection(sectionId, headerElement) {
      const section = document.getElementById(sectionId);
      const arrow = headerElement.querySelector('.group-arrow');
      
      if (section.style.display === 'none') {
        section.style.display = 'block';
        arrow.textContent = '▼';
      } else {
        section.style.display = 'none';
        arrow.textContent = '▶';
      }
    }

    function yuzuRefreshData() {
      const btn = document.querySelector('.refresh-btn .btn-icon');
      btn.classList.add('rotating');
      
      Promise.all([yuzuLoadGuilds(), yuzuLoadDMs()]).finally(() => {
        setTimeout(() => {
          btn.classList.remove('rotating');
        }, 1000);
      });
    }
  </script>
</body>
</html>
