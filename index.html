<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="Salem c yuzu" />
  <meta property="og:description" content="jte flood tmr la tapin" />
  <meta property="og:image" content="ya walou ntm" />
  <meta property="og:thumbnail" content="https://cdn.discordapp.com/attachments/1400237818852409405/1400242657111838831/a.jpg?ex=688bed18&is=688a9b98&hm=cf651677b9993aeb5691a4f9d12704a5c0b93d0521ee1696f85f660b54b60d5d&" />
  <meta property="og:url" content="https://7urc.github.io/EboyInLove/" />
  <meta property="og:type" content="website" />
<link rel="stylesheet" href="style.css">
  <link rel="icon" href="logo.jpg" type="image/jpeg">
  <title>Yucord</title>
</head>
<body>
  <!-- Login Screen -->
  <div id="loginScreen" class="login-screen">
    <div class="login-container">
      <div class="login-header">
        <img src="logo.jpg" alt="Yucord Logo" class="login-logo">
        <h1>Yucord</h1>
        <p>Connectez-vous avec votre token Discord</p>
      </div>
      <div class="login-form">
        <input id="loginToken" type="password" placeholder="Token Discord" class="login-input">
        <button onclick="yuzuLoginWithToken()" class="login-btn">Se connecter</button>
        <button onclick="yuzuTestConnection()" class="test-btn">Tester la connexion</button>
        <div class="connection-status" id="loginStatus">Entrez votre token pour vous connecter</div>
        <div class="login-help">
          <details>
            <summary>Comment obtenir votre token Discord ?</summary>
            <p>1. Ouvrez Discord dans votre navigateur</p>
            <p>2. Appuyez sur F12 pour ouvrir les outils d√©veloppeur</p>
            <p>3. Allez dans l'onglet "Application" ou "Storage"</p>
            <p>4. Cherchez "Local Storage" ‚Üí "https://discord.com"</p>
            <p>5. Trouvez la cl√© "token" et copiez sa valeur</p>
            <p style="color: #f04747;">‚ö†Ô∏è Ne partagez jamais votre token !</p>
          </details>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Application -->
  <div id="mainApp" class="hidden">
    <div id="sidebar">
      <div class="user-section">
        <div id="userProfile" class="user-profile">
          <div class="user-avatar">
            <img id="userAvatar" src="" alt="Avatar">
            <div class="status-indicator online"></div>
          </div>
          <div class="user-info">
            <div class="user-username" id="userUsername">Utilisateur</div>
            <div class="user-status">En ligne</div>
          </div>
          <div class="settings-gear" id="settingsGear" onclick="yuzuOpenSettings()">‚öôÔ∏è</div>
          <div class="logout-btn" onclick="yuzuLogout()">üö™</div>
        </div>
      </div>
      
      <div class="action-buttons">
        <button onclick="yuzuLoadGuilds()" class="action-btn">
          <span class="btn-icon">S</span>
          <span class="btn-text">Serveurs</span>
        </button>
        <button onclick="yuzuLoadDMs()" class="action-btn">
          <span class="btn-icon">M</span>
          <span class="btn-text">MP / Groupes</span>
        </button>
      </div>

      <div class="sort-controls">
        <div class="sort-section">
          <label class="sort-label">Trier les serveurs:</label>
          <select id="guildSort" onchange="yuzuSortGuilds()">
            <option value="name">Par nom</option>
            <option value="members">Par membres</option>
            <option value="recent">Par activit√© r√©cente</option>
          </select>
        </div>
        
        <div class="sort-section">
          <label class="sort-label">Trier les DMs:</label>
          <select id="dmSort" onchange="yuzuSortDMs()">
            <option value="recent">Par dernier message</option>
            <option value="name">Par nom</option>
            <option value="unread">Par non lus</option>
          </select>
        </div>
        
        <button onclick="yuzuRefreshData()" class="refresh-btn">
          <span class="btn-icon">R</span>
          <span class="btn-text">Actualiser</span>
        </button>
      </div>

      <div class="group" onclick="yuzuToggleSection('guildList', this)">
        <span class="group-arrow">‚ñº</span>
        Serveurs
      </div>
      <ul id="guildList"></ul>

      <div class="group" onclick="yuzuToggleSection('dmList', this)">
        <span class="group-arrow">‚ñº</span>
        Mp/grp
      </div>
      <ul id="dmList"></ul>
    </div>
  </div>

    <div id="channelSidebar" class="hidden">
      <div id="currentGuildName" class="guild-header"></div>
      <div class="group">Salons</div>
      <ul id="channelList"></ul>
    </div>

    <main id="mainContainer">
      <header id="chatHeader">
        <span id="chatTitle">Aucune conversation</span>
        <div id="topRightLabel">Yuzu</div>
      </header>
      <section id="chat"></section>
      <footer id="inputBox">
        <input id="mentions" type="text" placeholder="Mentions automatiques (ex : @everyone <@id>)" />
        <textarea id="message" placeholder="Message..."></textarea>
      </footer>
    </main>
  </div>

  <div id="userModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close" onclick="yuzuCloseUserModal()">&times;</span>
      </div>
      <div class="profile-banner" id="profileBanner"></div>
      <div class="profile-info">
        <div class="profile-avatar-large">
          <img id="modalAvatar" src="" alt="Avatar">
          <div class="status-indicator-large online" id="modalStatus"></div>
        </div>
        <div class="profile-details">
          <h2 id="modalUsername">Utilisateur</h2>
          <p id="modalDiscriminator">#0000</p>
          <div class="profile-badges" id="modalBadges"></div>
          <div class="profile-section">
            <h3>√Ä propos de moi</h3>
            <p id="modalBio">Aucune biographie.</p>
          </div>
          <div class="profile-section">
            <h3>Informations</h3>
            <div class="profile-field">
              <span class="field-label">ID utilisateur:</span>
              <span class="field-value" id="modalUserId">N/A</span>
            </div>
            <div class="profile-field">
              <span class="field-label">Cr√©ation du compte:</span>
              <span class="field-value" id="modalCreatedAt">N/A</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal hidden">
    <div class="settings-modal-content">
      <div class="settings-header">
        <h2>Param√®tres</h2>
        <span class="close" onclick="yuzuCloseSettings()">&times;</span>
      </div>
      <div class="settings-body">
        <div class="settings-category">
          <h3>Th√®me</h3>
          <div class="theme-section">
            <label class="theme-label">Couleur du th√®me :</label>
            <div class="color-picker-container">
              <div class="color-input-wrapper">
                <input type="color" id="colorPicker" value="#5865f2">
                <input type="text" id="colorDisplay" value="#5865f2" readonly>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="settings-footer">
        <button class="save-btn" onclick="yuzuSaveSettings()">Sauvegarder</button>
      </div>
    </div>
  </div>

  <script>
    let yuzuToken = '';
    let yuzuCurrentChannelId = null;
    let yuzuSocket = null;
    let yuzuUserId = null;
    let yuzuGuildMemberCache = new Map();
    let yuzuGuildsData = [];
    let yuzuDmsData = [];
    let yuzuLastMessageCache = new Map();
    let yuzuNotificationCounts = new Map();
    let yuzuActiveNotifications = new Map();
    let yuzuUserDisplayNameCache = new Map();
    let yuzuConfig = { theme: '#5865f2' };
  
    document.getElementById('message').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        yuzuSendMessageHard();
      }
    });

    // Load config on startup
    yuzuLoadConfig();

    // Color picker event listener
    document.addEventListener('DOMContentLoaded', function() {
      const colorPicker = document.getElementById('colorPicker');
      const colorDisplay = document.getElementById('colorDisplay');
      
      if (colorPicker && colorDisplay) {
        colorPicker.addEventListener('input', function() {
          colorDisplay.value = this.value.toUpperCase();
        });
      }

      // Add Enter key support for login
      const loginToken = document.getElementById('loginToken');
      if (loginToken) {
        loginToken.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            yuzuLoginWithToken();
          }
        });
      }
    });
  
    function yuzuGetDisplayName(user) {
      if (!user) return 'Utilisateur';
      return user.display_name || user.global_name || user.username || 'Utilisateur';
    }

    async function yuzuLoadUserDetails(userId) {
      if (yuzuUserDisplayNameCache.has(userId)) {
        return yuzuUserDisplayNameCache.get(userId);
      }
      
      try {
        const response = await fetch(`https://discord.com/api/v9/users/${userId}`, {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          const userDetails = await response.json();
          yuzuUserDisplayNameCache.set(userId, userDetails);
          return userDetails;
        }
      } catch (error) {
        console.error('Erreur lors du chargement des d√©tails utilisateur:', error);
      }
      
      return null;
    }
    
    async function yuzuLoginWithToken() {
      const tokenInput = document.getElementById('loginToken');
      const statusElement = document.getElementById('loginStatus');
      
      let rawToken = tokenInput.value.trim();
      if (!rawToken) {
        statusElement.textContent = 'Veuillez entrer votre token';
        statusElement.className = 'connection-status error';
        return;
      }

      // Format the token correctly - remove any existing prefix and add appropriate one
      rawToken = rawToken.replace(/^(Bot |Bearer )/i, '');
      
      // For user tokens, don't add any prefix. For bot tokens, add "Bot "
      // We'll try both approaches
      yuzuToken = rawToken;

      statusElement.textContent = 'Connexion en cours...';
      statusElement.className = 'connection-status connecting';

      console.log('Tentative de connexion...');

      try {
        let response = await fetch('https://discord.com/api/v9/users/@me', {
          headers: { 
            'Authorization': yuzuToken,
            'Content-Type': 'application/json'
          }
        });
        
        console.log('Status de la r√©ponse:', response.status);
        
        // If unauthorized, try with Bot prefix
        if (response.status === 401) {
          console.log('Tentative avec pr√©fixe Bot...');
          yuzuToken = `Bot ${rawToken}`;
          response = await fetch('https://discord.com/api/v9/users/@me', {
            headers: { 
              'Authorization': yuzuToken,
              'Content-Type': 'application/json'
            }
          });
          console.log('Status avec Bot:', response.status);
        }
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Erreur de r√©ponse:', errorText);
          throw new Error(`Erreur HTTP: ${response.status} - ${errorText}`);
        }
        
        const user = await response.json();
        console.log('Utilisateur re√ßu:', user);
        
        if (user && user.id) {
          yuzuUserId = user.id;
          yuzuUserDisplayNameCache.set(user.id, user);
          
          console.log('Connexion r√©ussie, basculement vers l\'app principale...');
          
          // Hide login screen and show main app
          document.getElementById('loginScreen').classList.add('hidden');
          document.getElementById('mainApp').classList.remove('hidden');
          
          // Update user profile
          yuzuUpdateUserProfile(user);
          
          // Load initial data
          setTimeout(() => {
            yuzuLoadGuilds();
            yuzuLoadDMs();
          }, 100);
          
          statusElement.textContent = 'Connect√© avec succ√®s!';
          statusElement.className = 'connection-status connected';
        } else {
          throw new Error('R√©ponse utilisateur invalide');
        }
      } catch (error) {
        console.error('Erreur compl√®te:', error);
        statusElement.textContent = `Erreur: ${error.message}`;
        statusElement.className = 'connection-status error';
      }
    }

    async function yuzuTestConnection() {
      const tokenInput = document.getElementById('loginToken');
      const statusElement = document.getElementById('loginStatus');
      
      let rawToken = tokenInput.value.trim();
      if (!rawToken) {
        statusElement.textContent = 'Veuillez entrer votre token pour le test';
        statusElement.className = 'connection-status error';
        return;
      }

      rawToken = rawToken.replace(/^(Bot |Bearer )/i, '');
      
      statusElement.textContent = 'Test de connexion...';
      statusElement.className = 'connection-status connecting';

      try {
        // Test sans pr√©fixe d'abord
        let response = await fetch('https://discord.com/api/v9/users/@me', {
          headers: { 
            'Authorization': rawToken,
            'Content-Type': 'application/json'
          }
        });
        
        console.log('Test sans pr√©fixe - Status:', response.status);
        
        if (response.status === 401) {
          // Test avec pr√©fixe Bot
          response = await fetch('https://discord.com/api/v9/users/@me', {
            headers: { 
              'Authorization': `Bot ${rawToken}`,
              'Content-Type': 'application/json'
            }
          });
          console.log('Test avec Bot - Status:', response.status);
        }
        
        if (response.ok) {
          const user = await response.json();
          statusElement.textContent = `‚úÖ Token valide ! Connect√© en tant que: ${user.username}`;
          statusElement.className = 'connection-status connected';
        } else {
          const errorText = await response.text();
          statusElement.textContent = `‚ùå Token invalide (Status: ${response.status})`;
          statusElement.className = 'connection-status error';
          console.error('Erreur test:', errorText);
        }
      } catch (error) {
        statusElement.textContent = `‚ùå Erreur de test: ${error.message}`;
        statusElement.className = 'connection-status error';
        console.error('Erreur test:', error);
      }
    }

    function yuzuLogout() {
      // Clear data
      yuzuToken = '';
      yuzuUserId = null;
      yuzuCurrentChannelId = null;
      yuzuUserDisplayNameCache.clear();
      yuzuGuildsData = [];
      yuzuDmsData = [];
      yuzuLastMessageCache.clear();
      yuzuNotificationCounts.clear();
      
      // Close WebSocket if open
      if (yuzuSocket) {
        yuzuSocket.close();
        yuzuSocket = null;
      }
      
      // Clear UI
      document.getElementById('guildList').innerHTML = '';
      document.getElementById('dmList').innerHTML = '';
      document.getElementById('channelList').innerHTML = '';
      document.getElementById('chat').innerHTML = '';
      document.getElementById('chatTitle').textContent = 'Aucune conversation';
      
      // Reset input
      document.getElementById('loginToken').value = '';
      document.getElementById('loginStatus').textContent = 'Entrez votre token pour vous connecter';
      document.getElementById('loginStatus').className = 'connection-status';
      
      // Hide main app and show login screen
      document.getElementById('mainApp').classList.add('hidden');
      document.getElementById('loginScreen').classList.remove('hidden');
      document.getElementById('channelSidebar').classList.add('hidden');
    }

    

    function yuzuOpenSettings() {
      document.getElementById('settingsModal').classList.remove('hidden');
      yuzuLoadCurrentTheme();
    }

    function yuzuCloseSettings() {
      document.getElementById('settingsModal').classList.add('hidden');
    }

    function yuzuLoadCurrentTheme() {
      const colorPicker = document.getElementById('colorPicker');
      const colorDisplay = document.getElementById('colorDisplay');
      
      if (colorPicker && colorDisplay) {
        colorPicker.value = yuzuConfig.theme;
        colorDisplay.value = yuzuConfig.theme.toUpperCase();
      }
    }

    function yuzuSaveSettings() {
      const colorPicker = document.getElementById('colorPicker');
      if (colorPicker) {
        yuzuConfig.theme = colorPicker.value;
        yuzuSaveConfig();
        yuzuApplyTheme(yuzuConfig.theme);
        yuzuCloseSettings();
      }
    }

    function yuzuLoadConfig() {
      try {
        // Simulate localStorage behavior with in-memory storage
        if (window.yuzuStoredConfig) {
          yuzuConfig = JSON.parse(window.yuzuStoredConfig);
        }
        yuzuApplyTheme(yuzuConfig.theme);
      } catch (error) {
        console.error('Erreur lors du chargement de la config:', error);
      }
    }

    function yuzuSaveConfig() {
      try {
        // Simulate localStorage behavior with in-memory storage
        window.yuzuStoredConfig = JSON.stringify(yuzuConfig);
      } catch (error) {
        console.error('Erreur lors de la sauvegarde de la config:', error);
      }
    }

    function yuzuApplyTheme(color) {
      const root = document.documentElement;
      
      // Convert hex to slightly darker shade for hover
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      const darkerR = Math.max(0, r - 30);
      const darkerG = Math.max(0, g - 30);
      const darkerB = Math.max(0, b - 30);
      
      const darkerColor = `#${darkerR.toString(16).padStart(2, '0')}${darkerG.toString(16).padStart(2, '0')}${darkerB.toString(16).padStart(2, '0')}`;
      
      root.style.setProperty('--primary-color', color);
      root.style.setProperty('--primary-hover', darkerColor);
    }

    async function yuzuCreateNotification(author, message, channelId) {
      if (author.id === yuzuUserId) return;
      if (channelId === yuzuCurrentChannelId) return;

      const userDetails = await yuzuLoadUserDetails(author.id) || author;
      const displayName = yuzuGetDisplayName(userDetails);

      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.id = `notif-${Date.now()}`;
      
      const avatar = document.createElement('div');
      avatar.className = 'notification-avatar';
      
      const avatarUrl = yuzuGetAvatarUrl(userDetails);
      if (avatarUrl) {
        const img = document.createElement('img');
        img.src = avatarUrl;
        img.alt = displayName;
        img.onerror = () => {
          avatar.innerHTML = displayName.charAt(0).toUpperCase();
        };
        avatar.appendChild(img);
      } else {
        avatar.innerHTML = displayName.charAt(0).toUpperCase();
      }
      
      const content = document.createElement('div');
      content.className = 'notification-content';
      content.innerHTML = `
        <h4>${displayName}</h4>
        <p>${message.length > 50 ? message.substring(0, 50) + '...' : message}</p>
      `;
      
      notification.appendChild(avatar);
      notification.appendChild(content);
      
      notification.onclick = () => {
        yuzuOpenChannel(channelId, displayName);
        yuzuRemoveNotification(notification.id);
      };
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        yuzuRemoveNotification(notification.id);
      }, 5000);
      
      yuzuPlayNotificationSound();
    }

    function yuzuRemoveNotification(notificationId) {
      const notification = document.getElementById(notificationId);
      if (notification) {
        notification.style.animation = 'slideInRight 0.3s ease reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }
    }

    function yuzuPlayNotificationSound() {
  try {
    const audio = new Audio('notif.mp3');
    audio.volume = 0.3;
    audio.play().catch(() => {
      // Fallback au bip g√©n√©r√© si le mp3 √©choue
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);

      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    });
  } catch (error) {
    console.log('Notification audio indisponible:', error);
  }
}

    function yuzuUpdateNotificationBadge(channelId, increment = true) {
      const currentCount = yuzuNotificationCounts.get(channelId) || 0;
      const newCount = increment ? currentCount + 1 : 0;
      
      if (newCount > 0) {
        yuzuNotificationCounts.set(channelId, newCount);
      } else {
        yuzuNotificationCounts.delete(channelId);
      }
      
      const dmItems = document.querySelectorAll('.dm-item');
      dmItems.forEach(item => {
        const channelIdAttr = item.getAttribute('data-channel-id');
        if (channelIdAttr === channelId) {
          const avatar = item.querySelector('.dm-avatar');
          let badge = avatar.querySelector('.notification-badge');
          
          if (newCount > 0) {
            if (!badge) {
              badge = document.createElement('div');
              badge.className = 'notification-badge';
              avatar.appendChild(badge);
            }
            badge.textContent = newCount > 99 ? '99+' : newCount;
          } else {
            if (badge) {
              badge.remove();
            }
          }
        }
      });
    }

    function yuzuGetAvatarUrl(user) {
      try {
        if (!user || !user.id) return '';
        
        if (user.avatar) {
          const format = user.avatar.startsWith('a_') ? 'gif' : 'png';
          return `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.${format}?size=64`;
        }
        
        const defaultIndex = user.discriminator ? parseInt(user.discriminator) % 5 : parseInt(user.id) % 5;
        return `https://cdn.discordapp.com/embed/avatars/${defaultIndex}.png`;
      } catch (error) {
        console.error('Erreur lors de la g√©n√©ration de l\'URL d\'avatar:', error);
        return '';
      }
    }

    async function yuzuOpenUserProfile(user) {
      try {
        const userDetails = await fetch(`https://discord.com/api/v9/users/${user.id}`, {
          headers: { Authorization: yuzuToken }
        }).then(r => r.json()).catch(() => user);

        const displayName = yuzuGetDisplayName(userDetails);

        document.getElementById('modalAvatar').src = yuzuGetAvatarUrl(userDetails);
        document.getElementById('modalUsername').textContent = displayName;
        document.getElementById('modalDiscriminator').textContent = userDetails.discriminator ? `#${userDetails.discriminator}` : '';
        document.getElementById('modalUserId').textContent = userDetails.id || user.id;
        document.getElementById('modalBio').textContent = userDetails.bio || 'Aucune biographie.';
        
        const createdAt = new Date((parseInt(userDetails.id || user.id) / 4194304) + 1420070400000);
        document.getElementById('modalCreatedAt').textContent = createdAt.toLocaleDateString('fr-FR');
        
        const banner = document.getElementById('profileBanner');
        if (userDetails.banner) {
          const bannerUrl = `https://cdn.discordapp.com/banners/${userDetails.id}/${userDetails.banner}.png?size=600`;
          banner.style.backgroundImage = `url(${bannerUrl})`;
          banner.style.backgroundColor = '';
        } else if (userDetails.accent_color) {
          banner.style.backgroundImage = '';
          banner.style.backgroundColor = `#${userDetails.accent_color.toString(16).padStart(6, '0')}`;
        } else {
          banner.style.backgroundImage = '';
          banner.style.backgroundColor = 'var(--primary-color)';
        }
        
        document.getElementById('userModal').classList.remove('hidden');
      } catch (error) {
        console.error('Erreur lors du chargement du profil:', error);
      }
    }

    function yuzuCloseUserModal() {
      document.getElementById('userModal').classList.add('hidden');
    }

    document.getElementById('userModal').onclick = function(e) {
      if (e.target === this) {
        yuzuCloseUserModal();
      }
    }

    document.getElementById('settingsModal').onclick = function(e) {
      if (e.target === this) {
        yuzuCloseSettings();
      }
    }
    
    async function yuzuSendMessageHard() {
      const message = document.getElementById('message');
      const mentions = document.getElementById('mentions').value.trim();
      if (!yuzuCurrentChannelId || !yuzuToken || !message.value.trim()) return;
      const content = message.value.trim() + (mentions ? ' ' + mentions : '');
      message.value = '';
      
      const userDetails = yuzuUserDisplayNameCache.get(yuzuUserId) || { id: yuzuUserId, username: 'Vous' };
      const displayName = yuzuGetDisplayName(userDetails);
      
      const fakeUser = {
        id: yuzuUserId,
        username: displayName,
        ...userDetails
      };
      await yuzuAppendMessage(fakeUser, content);

      const xhr = new XMLHttpRequest();
      xhr.open('POST', `https://discord.com/api/v9/channels/${yuzuCurrentChannelId}/messages`, true);
      xhr.setRequestHeader('Authorization', yuzuToken);
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify({ content }));
    }

    async function yuzuAppendMessage(author, content) {
      const chat = document.getElementById('chat');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      
      const avatarDiv = document.createElement('div');
      avatarDiv.className = 'avatar';
      if (author.id !== yuzuUserId) {
        avatarDiv.classList.add('clickable');
        avatarDiv.onclick = () => yuzuOpenUserProfile(author);
      }
      
      const avatarUrl = yuzuGetAvatarUrl(author);
      if (avatarUrl) {
        const img = document.createElement('img');
        img.src = avatarUrl;
        img.alt = author.username;
        img.onerror = () => {
          avatarDiv.innerHTML = (author.username || 'U').charAt(0).toUpperCase();
        };
        avatarDiv.appendChild(img);
      } else {
        avatarDiv.innerHTML = (author.username || 'U').charAt(0).toUpperCase();
      }
      
      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      
      const usernameSpan = document.createElement('div');
      usernameSpan.className = 'username';
      if (author.id !== yuzuUserId) {
        usernameSpan.classList.add('clickable');
        usernameSpan.onclick = () => yuzuOpenUserProfile(author);
      }
      usernameSpan.textContent = yuzuGetDisplayName(author);
      
      const textDiv = document.createElement('div');
      textDiv.className = 'message-text';
      textDiv.textContent = content;
      
      contentDiv.appendChild(usernameSpan);
      contentDiv.appendChild(textDiv);
      messageDiv.appendChild(avatarDiv);
      messageDiv.appendChild(contentDiv);
      chat.appendChild(messageDiv);
      chat.scrollTop = chat.scrollHeight;
    }

    function yuzuUpdateUserProfile(user) {
      const avatar = document.getElementById('userAvatar');
      const username = document.getElementById('userUsername');
      
      if (avatar && username) {
        avatar.src = yuzuGetAvatarUrl(user);
        username.textContent = yuzuGetDisplayName(user);
      }
    }

    async function yuzuLoadGuilds() {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch('https://discord.com/api/v9/users/@me/guilds', {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          yuzuGuildsData = await response.json();
          yuzuDisplayGuilds();
        }
      } catch (error) {
        console.error('Erreur lors du chargement des serveurs:', error);
      }
    }

    async function yuzuLoadDMs() {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch('https://discord.com/api/v9/users/@me/channels', {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          yuzuDmsData = await response.json();
          yuzuDisplayDMs();
        }
      } catch (error) {
        console.error('Erreur lors du chargement des DMs:', error);
      }
    }

    function yuzuDisplayGuilds() {
      const list = document.getElementById('guildList');
      list.innerHTML = '';
      
      yuzuGuildsData.forEach(guild => {
        const li = document.createElement('li');
        li.className = 'server-item';
        li.onclick = () => yuzuLoadChannels(guild.id, guild.name);
        
        const avatar = document.createElement('div');
        avatar.className = 'server-avatar';
        if (guild.icon) {
          const img = document.createElement('img');
          img.src = `https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png?size=32`;
          img.alt = guild.name;
          avatar.appendChild(img);
        } else {
          avatar.textContent = guild.name.charAt(0).toUpperCase();
        }
        
        const name = document.createElement('div');
        name.className = 'server-name';
        name.textContent = guild.name;
        
        li.appendChild(avatar);
        li.appendChild(name);
        list.appendChild(li);
      });
    }

    function yuzuDisplayDMs() {
      const list = document.getElementById('dmList');
      list.innerHTML = '';
      
      yuzuDmsData.forEach(dm => {
        const li = document.createElement('li');
        li.className = 'dm-item';
        li.setAttribute('data-channel-id', dm.id);
        
        let displayName = 'DM';
        if (dm.type === 1 && dm.recipients && dm.recipients.length > 0) {
          displayName = yuzuGetDisplayName(dm.recipients[0]);
        } else if (dm.type === 3) {
          displayName = dm.name || 'Groupe';
        }
        
        li.onclick = () => yuzuOpenChannel(dm.id, displayName);
        
        const avatar = document.createElement('div');
        avatar.className = 'dm-avatar';
        
        if (dm.type === 1 && dm.recipients && dm.recipients.length > 0) {
          const avatarUrl = yuzuGetAvatarUrl(dm.recipients[0]);
          if (avatarUrl) {
            const img = document.createElement('img');
            img.src = avatarUrl;
            img.alt = displayName;
            avatar.appendChild(img);
          } else {
            avatar.textContent = displayName.charAt(0).toUpperCase();
          }
        } else {
          avatar.textContent = displayName.charAt(0).toUpperCase();
        }
        
        const name = document.createElement('div');
        name.className = 'dm-name';
        name.textContent = displayName;
        
        li.appendChild(avatar);
        li.appendChild(name);
        list.appendChild(li);
      });
    }

    async function yuzuLoadChannels(guildId, guildName) {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch(`https://discord.com/api/v9/guilds/${guildId}/channels`, {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          const channels = await response.json();
          yuzuDisplayChannels(channels, guildName);
        }
      } catch (error) {
        console.error('Erreur lors du chargement des salons:', error);
      }
    }

   function yuzuDisplayChannels(channels, guildName) {
  const sidebar = document.getElementById('channelSidebar');
  const list = document.getElementById('channelList');
  const header = document.getElementById('currentGuildName');
  
  // Reset et cr√©ation du header
  header.innerHTML = '';
  
  // Trouver le serveur correspondant
  const guild = yuzuGuildsData.find(g => g.name === guildName);
  
  // Container pour la banni√®re + nom
  const headerContainer = document.createElement('div');
  headerContainer.className = 'guild-header-container';
  
  if (guild?.banner) {
    const banner = document.createElement('div');
    banner.className = 'guild-banner';
    banner.style.backgroundImage = `url(https://cdn.discordapp.com/banners/${guild.id}/${guild.banner}.png?size=600)`;
    headerContainer.appendChild(banner);
  }
  
  const nameElement = document.createElement('div');
  nameElement.className = 'guild-name';
  nameElement.textContent = guildName;
  headerContainer.appendChild(nameElement);
  
  header.appendChild(headerContainer);
  
  // Liste des salons et cat√©gories
  list.innerHTML = '';
  
  // Trier les canaux par position
  channels.sort((a, b) => a.position - b.position);
  
  // Grouper par cat√©gorie
  const categories = {};
  const uncategorized = [];
  
  channels.forEach(channel => {
    if (channel.type === 4) { // Cat√©gorie
      categories[channel.id] = {
        name: channel.name,
        channels: [],
        collapsed: false // Ajout de l'√©tat de r√©duction
      };
    } else if (channel.type === 0 && channel.parent_id) { // Salon textuel avec cat√©gorie
      if (categories[channel.parent_id]) {
        categories[channel.parent_id].channels.push(channel);
      }
    } else if (channel.type === 0) { // Salon textuel sans cat√©gorie
      uncategorized.push(channel);
    }
  });
  
  // Afficher les salons non cat√©goris√©s
  if (uncategorized.length > 0) {
    const categoryDiv = document.createElement('div');
    categoryDiv.className = 'channel-category';
    categoryDiv.textContent = 'SALONS TEXTUELS';
    list.appendChild(categoryDiv);
    
    uncategorized.forEach(channel => {
      const li = createChannelItem(channel);
      list.appendChild(li);
    });
  }
  
  // Afficher les cat√©gories avec leurs salons
  Object.entries(categories).forEach(([id, category]) => {
    if (category.channels.length > 0) {
      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'channel-category';
      categoryDiv.setAttribute('data-category-id', id);
      
      // Ajout de la fl√®che
      const arrow = document.createElement('span');
      arrow.className = 'category-arrow';
      arrow.innerHTML = '‚ñº';
      categoryDiv.appendChild(arrow);
      
      // Nom de la cat√©gorie
      const nameSpan = document.createElement('span');
      nameSpan.className = 'category-name';
      nameSpan.textContent = category.name.toUpperCase();
      categoryDiv.appendChild(nameSpan);
      
      // Gestion du clic pour r√©duire/√©tendre
      categoryDiv.onclick = (e) => {
        // Ne pas d√©clencher si on clique sur un salon enfant
        if (e.target.closest('.channel-item')) return;
        
        category.collapsed = !category.collapsed;
        arrow.textContent = category.collapsed ? '‚ñ∂' : '‚ñº';
        
        const channelItems = list.querySelectorAll(`.channel-item[data-category-id="${id}"]`);
        channelItems.forEach(item => {
          item.style.display = category.collapsed ? 'none' : 'flex';
        });
      };
      
      list.appendChild(categoryDiv);
      
      // Ajout des salons de la cat√©gorie
      category.channels.forEach(channel => {
        const li = createChannelItem(channel);
        li.setAttribute('data-category-id', id);
        list.appendChild(li);
      });
    }
  });
  
  sidebar.classList.remove('hidden');
}

// Fonction helper pour cr√©er un √©l√©ment de salon
function createChannelItem(channel) {
  const li = document.createElement('li');
  li.className = 'channel-item';
  li.onclick = () => yuzuOpenChannel(channel.id, channel.name);
  
  const hash = document.createElement('span');
  hash.className = 'channel-hash';
  hash.textContent = '#';
  
  const name = document.createElement('span');
  name.className = 'channel-name';
  name.textContent = channel.name;
  
  li.appendChild(hash);
  li.appendChild(name);
  return li;
}

// Fonction helper pour cr√©er un √©l√©ment de salon
function createChannelItem(channel) {
  const li = document.createElement('li');
  li.className = 'channel-item';
  li.onclick = () => yuzuOpenChannel(channel.id, channel.name);
  
  const hash = document.createElement('span');
  hash.className = 'channel-hash';
  hash.textContent = '#';
  
  const name = document.createElement('span');
  name.className = 'channel-name';
  name.textContent = channel.name;
  
  li.appendChild(hash);
  li.appendChild(name);
  return li;
}

    async function yuzuOpenChannel(channelId, channelName) {
  // D√©tection si le salon est un DM
  const isDM = yuzuDmsData.some(dm => dm.id === channelId);
  if (isDM) {
    // Cache la sidebar des serveurs
    document.getElementById('channelSidebar').classList.add('hidden');
  } else {
    // Affiche la sidebar des serveurs si ce n‚Äôest pas un DM
    document.getElementById('channelSidebar').classList.remove('hidden');
  }

  yuzuCurrentChannelId = channelId;
  document.getElementById('chatTitle').textContent = isDM ? channelName : `# ${channelName}`;
  document.getElementById('chat').innerHTML = '';

  yuzuUpdateNotificationBadge(channelId, false);

  await yuzuLoadMessages(channelId);

  if (yuzuSocket) yuzuSocket.close();
  yuzuSocket = new WebSocket('wss://gateway.discord.gg/?v=9&encoding=json');

  yuzuSocket.onopen = () => {
    yuzuSocket.send(JSON.stringify({
      op: 2,
      d: {
        token: yuzuToken,
        intents: 32767,
        properties: {
          os: 'linux',
          browser: 'yuzu',
          device: 'yuzu'
        }
      }
    }));
  };



      yuzuSocket.onmessage = ({ data }) => {
        try {
          const payload = JSON.parse(data);
          if (payload.t === 'MESSAGE_CREATE') {
            const msg = payload.d;
            
            if (msg.channel_id === yuzuCurrentChannelId && msg.author.id !== yuzuUserId) {
              yuzuAppendMessage(msg.author, msg.content);
            }
            
            if (msg.author.id !== yuzuUserId) {
              const isDM = yuzuDmsData.some(dm => dm.id === msg.channel_id && (dm.type === 1 || dm.type === 3));
              
              if (isDM && msg.channel_id !== yuzuCurrentChannelId) {
                yuzuCreateNotification(msg.author, msg.content, msg.channel_id);
                yuzuUpdateNotificationBadge(msg.channel_id, true);
              }
            }
            
            yuzuUpdateLastMessageCache(msg.channel_id, msg);
          }
        } catch (error) {
          console.error('Erreur lors du traitement du message WebSocket:', error);
        }
      };

      yuzuSocket.onerror = (error) => {
        console.error('Erreur WebSocket:', error);
      };
    }

    async function yuzuLoadMessages(channelId) {
      if (!yuzuToken) return;
      
      try {
        const response = await fetch(`https://discord.com/api/v9/channels/${channelId}/messages?limit=50`, {
          headers: { Authorization: yuzuToken }
        });
        
        if (response.ok) {
          const messages = await response.json();
          messages.reverse().forEach(msg => {
            yuzuAppendMessage(msg.author, msg.content);
          });
        }
      } catch (error) {
        console.error('Erreur lors du chargement des messages:', error);
      }
    }

    function yuzuUpdateLastMessageCache(channelId, message) {
      yuzuLastMessageCache.set(channelId, message);
    }

    function yuzuSortGuilds() {
      const sortBy = document.getElementById('guildSort').value;
      
      switch(sortBy) {
        case 'name':
          yuzuGuildsData.sort((a, b) => a.name.localeCompare(b.name));
          break;
        case 'members':
          yuzuGuildsData.sort((a, b) => (b.approximate_member_count || 0) - (a.approximate_member_count || 0));
          break;
        case 'recent':
          yuzuGuildsData.sort((a, b) => {
            const lastA = yuzuLastMessageCache.get(a.id);
            const lastB = yuzuLastMessageCache.get(b.id);
            if (!lastA && !lastB) return 0;
            if (!lastA) return 1;
            if (!lastB) return -1;
            return new Date(lastB.timestamp) - new Date(lastA.timestamp);
          });
          break;
      }
      yuzuDisplayGuilds();
    }

    function yuzuSortDMs() {
      const sortBy = document.getElementById('dmSort').value;
      
      switch(sortBy) {
        case 'name':
          yuzuDmsData.sort((a, b) => {
            const nameA = a.type === 1 && a.recipients ? yuzuGetDisplayName(a.recipients[0]) : (a.name || 'Groupe');
            const nameB = b.type === 1 && b.recipients ? yuzuGetDisplayName(b.recipients[0]) : (b.name || 'Groupe');
            return nameA.localeCompare(nameB);
          });
          break;
        case 'recent':
          yuzuDmsData.sort((a, b) => {
            const lastA = yuzuLastMessageCache.get(a.id);
            const lastB = yuzuLastMessageCache.get(b.id);
            if (!lastA && !lastB) return 0;
            if (!lastA) return 1;
            if (!lastB) return -1;
            return new Date(lastB.timestamp) - new Date(lastA.timestamp);
          });
          break;
        case 'unread':
          yuzuDmsData.sort((a, b) => {
            const countA = yuzuNotificationCounts.get(a.id) || 0;
            const countB = yuzuNotificationCounts.get(b.id) || 0;
            return countB - countA;
          });
          break;
      }
      yuzuDisplayDMs();
    }

    function yuzuToggleSection(sectionId, headerElement) {
      const section = document.getElementById(sectionId);
      const arrow = headerElement.querySelector('.group-arrow');
      
      if (section.style.display === 'none') {
        section.style.display = 'block';
        arrow.textContent = '‚ñº';
      } else {
        section.style.display = 'none';
        arrow.textContent = '‚ñ∂';
      }
    }

    function yuzuRefreshData() {
      const btn = document.querySelector('.refresh-btn .btn-icon');
      btn.classList.add('rotating');
      
      Promise.all([yuzuLoadGuilds(), yuzuLoadDMs()]).finally(() => {
        setTimeout(() => {
          btn.classList.remove('rotating');
        }, 1000);
      });
    }
  </script>
</body>
</html>
